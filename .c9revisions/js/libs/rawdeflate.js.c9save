{"ts":1359549670625,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n * $Id: rawdeflate.js,v 0.3 2009/03/01 19:05:05 dankogai Exp dankogai $\n *\n * Original:\n *   http://www.onicos.com/staff/iz/amuse/javascript/expert/deflate.txt\n */\n\n(function(){\n\n/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0.1\n * LastModified: Dec 25 1999\n */\n\n/* Interface:\n * data = zip_deflate(src);\n */\n\n/* constant parameters */\nvar zip_WSIZE = 32768;\t\t// Sliding Window size\nvar zip_STORED_BLOCK = 0;\nvar zip_STATIC_TREES = 1;\nvar zip_DYN_TREES    = 2;\n\n/* for deflate */\nvar zip_DEFAULT_LEVEL = 6;\nvar zip_FULL_SEARCH = true;\nvar zip_INBUFSIZ = 32768;\t// Input buffer size\nvar zip_INBUF_EXTRA = 64;\t// Extra buffer\nvar zip_OUTBUFSIZ = 1024 * 8;\nvar zip_window_size = 2 * zip_WSIZE;\nvar zip_MIN_MATCH = 3;\nvar zip_MAX_MATCH = 258;\nvar zip_BITS = 16;\n// for SMALL_MEM\nvar zip_LIT_BUFSIZE = 0x2000;\nvar zip_HASH_BITS = 13;\n// for MEDIUM_MEM\n// var zip_LIT_BUFSIZE = 0x4000;\n// var zip_HASH_BITS = 14;\n// for BIG_MEM\n// var zip_LIT_BUFSIZE = 0x8000;\n// var zip_HASH_BITS = 15;\nif(zip_LIT_BUFSIZE > zip_INBUFSIZ)\n    alert(\"error: zip_INBUFSIZ is too small\");\nif((zip_WSIZE<<1) > (1<<zip_BITS))\n    alert(\"error: zip_WSIZE is too large\");\nif(zip_HASH_BITS > zip_BITS-1)\n    alert(\"error: zip_HASH_BITS is too large\");\nif(zip_HASH_BITS < 8 || zip_MAX_MATCH != 258)\n    alert(\"error: Code too clever\");\nvar zip_DIST_BUFSIZE = zip_LIT_BUFSIZE;\nvar zip_HASH_SIZE = 1 << zip_HASH_BITS;\nvar zip_HASH_MASK = zip_HASH_SIZE - 1;\nvar zip_WMASK = zip_WSIZE - 1;\nvar zip_NIL = 0; // Tail of hash chains\nvar zip_TOO_FAR = 4096;\nvar zip_MIN_LOOKAHEAD = zip_MAX_MATCH + zip_MIN_MATCH + 1;\nvar zip_MAX_DIST = zip_WSIZE - zip_MIN_LOOKAHEAD;\nvar zip_SMALLEST = 1;\nvar zip_MAX_BITS = 15;\nvar zip_MAX_BL_BITS = 7;\nvar zip_LENGTH_CODES = 29;\nvar zip_LITERALS =256;\nvar zip_END_BLOCK = 256;\nvar zip_L_CODES = zip_LITERALS + 1 + zip_LENGTH_CODES;\nvar zip_D_CODES = 30;\nvar zip_BL_CODES = 19;\nvar zip_REP_3_6 = 16;\nvar zip_REPZ_3_10 = 17;\nvar zip_REPZ_11_138 = 18;\nvar zip_HEAP_SIZE = 2 * zip_L_CODES + 1;\nvar zip_H_SHIFT = parseInt((zip_HASH_BITS + zip_MIN_MATCH - 1) /\n\t\t\t   zip_MIN_MATCH);\n\n/* variables */\nvar zip_free_queue;\nvar zip_qhead, zip_qtail;\nvar zip_initflag;\nvar zip_outbuf = null;\nvar zip_outcnt, zip_outoff;\nvar zip_complete;\nvar zip_window;\nvar zip_d_buf;\nvar zip_l_buf;\nvar zip_prev;\nvar zip_bi_buf;\nvar zip_bi_valid;\nvar zip_block_start;\nvar zip_ins_h;\nvar zip_hash_head;\nvar zip_prev_match;\nvar zip_match_available;\nvar zip_match_length;\nvar zip_prev_length;\nvar zip_strstart;\nvar zip_match_start;\nvar zip_eofile;\nvar zip_lookahead;\nvar zip_max_chain_length;\nvar zip_max_lazy_match;\nvar zip_compr_level;\nvar zip_good_match;\nvar zip_nice_match;\nvar zip_dyn_ltree;\nvar zip_dyn_dtree;\nvar zip_static_ltree;\nvar zip_static_dtree;\nvar zip_bl_tree;\nvar zip_l_desc;\nvar zip_d_desc;\nvar zip_bl_desc;\nvar zip_bl_count;\nvar zip_heap;\nvar zip_heap_len;\nvar zip_heap_max;\nvar zip_depth;\nvar zip_length_code;\nvar zip_dist_code;\nvar zip_base_length;\nvar zip_base_dist;\nvar zip_flag_buf;\nvar zip_last_lit;\nvar zip_last_dist;\nvar zip_last_flags;\nvar zip_flags;\nvar zip_flag_bit;\nvar zip_opt_len;\nvar zip_static_len;\nvar zip_deflate_data;\nvar zip_deflate_pos;\n\n/* objects (deflate) */\n\nvar zip_DeflateCT = function() {\n    this.fc = 0; // frequency count or bit string\n    this.dl = 0; // father node in Huffman tree or length of bit string\n}\n\nvar zip_DeflateTreeDesc = function() {\n    this.dyn_tree = null;\t// the dynamic tree\n    this.static_tree = null;\t// corresponding static tree or NULL\n    this.extra_bits = null;\t// extra bits for each code or NULL\n    this.extra_base = 0;\t// base index for extra_bits\n    this.elems = 0;\t\t// max number of elements in the tree\n    this.max_length = 0;\t// max bit length for the codes\n    this.max_code = 0;\t\t// largest code with non zero frequency\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nvar zip_DeflateConfiguration = function(a, b, c, d) {\n    this.good_length = a; // reduce lazy search above this match length\n    this.max_lazy = b;    // do not perform lazy search above this match length\n    this.nice_length = c; // quit search above this match length\n    this.max_chain = d;\n}\n\nvar zip_DeflateBuffer = function() {\n    this.next = null;\n    this.len = 0;\n    this.ptr = new Array(zip_OUTBUFSIZ);\n    this.off = 0;\n}\n\n/* constant tables */\nvar zip_extra_lbits = new Array(\n    0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0);\nvar zip_extra_dbits = new Array(\n    0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13);\nvar zip_extra_blbits = new Array(\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7);\nvar zip_bl_order = new Array(\n    16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15);\nvar zip_configuration_table = new Array(\n\tnew zip_DeflateConfiguration(0,    0,   0,    0),\n\tnew zip_DeflateConfiguration(4,    4,   8,    4),\n\tnew zip_DeflateConfiguration(4,    5,  16,    8),\n\tnew zip_DeflateConfiguration(4,    6,  32,   32),\n\tnew zip_DeflateConfiguration(4,    4,  16,   16),\n\tnew zip_DeflateConfiguration(8,   16,  32,   32),\n\tnew zip_DeflateConfiguration(8,   16, 128,  128),\n\tnew zip_DeflateConfiguration(8,   32, 128,  256),\n\tnew zip_DeflateConfiguration(32, 128, 258, 1024),\n\tnew zip_DeflateConfiguration(32, 258, 258, 4096));\n\n\n/* routines (deflate) */\n\nvar zip_deflate_start = function(level) {\n    var i;\n\n    if(!level)\n\tlevel = zip_DEFAULT_LEVEL;\n    else if(level < 1)\n\tlevel = 1;\n    else if(level > 9)\n\tlevel = 9;\n\n    zip_compr_level = level;\n    zip_initflag = false;\n    zip_eofile = false;\n    if(zip_outbuf != null)\n\treturn;\n\n    zip_free_queue = zip_qhead = zip_qtail = null;\n    zip_outbuf = new Array(zip_OUTBUFSIZ);\n    zip_window = new Array(zip_window_size);\n    zip_d_buf = new Array(zip_DIST_BUFSIZE);\n    zip_l_buf = new Array(zip_INBUFSIZ + zip_INBUF_EXTRA);\n    zip_prev = new Array(1 << zip_BITS);\n    zip_dyn_ltree = new Array(zip_HEAP_SIZE);\n    for(i = 0; i < zip_HEAP_SIZE; i++)\n\tzip_dyn_ltree[i] = new zip_DeflateCT();\n    zip_dyn_dtree = new Array(2*zip_D_CODES+1);\n    for(i = 0; i < 2*zip_D_CODES+1; i++)\n\tzip_dyn_dtree[i] = new zip_DeflateCT();\n    zip_static_ltree = new Array(zip_L_CODES+2);\n    for(i = 0; i < zip_L_CODES+2; i++)\n\tzip_static_ltree[i] = new zip_DeflateCT();\n    zip_static_dtree = new Array(zip_D_CODES);\n    for(i = 0; i < zip_D_CODES; i++)\n\tzip_static_dtree[i] = new zip_DeflateCT();\n    zip_bl_tree = new Array(2*zip_BL_CODES+1);\n    for(i = 0; i < 2*zip_BL_CODES+1; i++)\n\tzip_bl_tree[i] = new zip_DeflateCT();\n    zip_l_desc = new zip_DeflateTreeDesc();\n    zip_d_desc = new zip_DeflateTreeDesc();\n    zip_bl_desc = new zip_DeflateTreeDesc();\n    zip_bl_count = new Array(zip_MAX_BITS+1);\n    zip_heap = new Array(2*zip_L_CODES+1);\n    zip_depth = new Array(2*zip_L_CODES+1);\n    zip_length_code = new Array(zip_MAX_MATCH-zip_MIN_MATCH+1);\n    zip_dist_code = new Array(512);\n    zip_base_length = new Array(zip_LENGTH_CODES);\n    zip_base_dist = new Array(zip_D_CODES);\n    zip_flag_buf = new Array(parseInt(zip_LIT_BUFSIZE / 8));\n}\n\nvar zip_deflate_end = function() {\n    zip_free_queue = zip_qhead = zip_qtail = null;\n    zip_outbuf = null;\n    zip_window = null;\n    zip_d_buf = null;\n    zip_l_buf = null;\n    zip_prev = null;\n    zip_dyn_ltree = null;\n    zip_dyn_dtree = null;\n    zip_static_ltree = null;\n    zip_static_dtree = null;\n    zip_bl_tree = null;\n    zip_l_desc = null;\n    zip_d_desc = null;\n    zip_bl_desc = null;\n    zip_bl_count = null;\n    zip_heap = null;\n    zip_depth = null;\n    zip_length_code = null;\n    zip_dist_code = null;\n    zip_base_length = null;\n    zip_base_dist = null;\n    zip_flag_buf = null;\n}\n\nvar zip_reuse_queue = function(p) {\n    p.next = zip_free_queue;\n    zip_free_queue = p;\n}\n\nvar zip_new_queue = function() {\n    var p;\n\n    if(zip_free_queue != null)\n    {\n\tp = zip_free_queue;\n\tzip_free_queue = zip_free_queue.next;\n    }\n    else\n\tp = new zip_DeflateBuffer();\n    p.next = null;\n    p.len = p.off = 0;\n\n    return p;\n}\n\nvar zip_head1 = function(i) {\n    return zip_prev[zip_WSIZE + i];\n}\n\nvar zip_head2 = function(i, val) {\n    return zip_prev[zip_WSIZE + i] = val;\n}\n\n/* put_byte is used for the compressed output, put_ubyte for the\n * uncompressed output. However unlzw() uses window for its\n * suffix table instead of its output buffer, so it does not use put_ubyte\n * (to be cleaned up).\n */\nvar zip_put_byte = function(c) {\n    zip_outbuf[zip_outoff + zip_outcnt++] = c;\n    if(zip_outoff + zip_outcnt == zip_OUTBUFSIZ)\n\tzip_qoutbuf();\n}\n\n/* Output a 16 bit value, lsb first */\nvar zip_put_short = function(w) {\n    w &= 0xffff;\n    if(zip_outoff + zip_outcnt < zip_OUTBUFSIZ - 2) {\n\tzip_outbuf[zip_outoff + zip_outcnt++] = (w & 0xff);\n\tzip_outbuf[zip_outoff + zip_outcnt++] = (w >>> 8);\n    } else {\n\tzip_put_byte(w & 0xff);\n\tzip_put_byte(w >>> 8);\n    }\n}\n\n/* ==========================================================================\n * Insert string s in the dictionary and set match_head to the previous head\n * of the hash chain (the most recent string with same hash key). Return\n * the previous length of the hash chain.\n * IN  assertion: all calls to to INSERT_STRING are made with consecutive\n *    input characters and the first MIN_MATCH bytes of s are valid\n *    (except for the last MIN_MATCH-1 bytes of the input file).\n */\nvar zip_INSERT_STRING = function() {\n    zip_ins_h = ((zip_ins_h << zip_H_SHIFT)\n\t\t ^ (zip_window[zip_strstart + zip_MIN_MATCH - 1] & 0xff))\n\t& zip_HASH_MASK;\n    zip_hash_head = zip_head1(zip_ins_h);\n    zip_prev[zip_strstart & zip_WMASK] = zip_hash_head;\n    zip_head2(zip_ins_h, zip_strstart);\n}\n\n/* Send a code of the given tree. c and tree must not have side effects */\nvar zip_SEND_CODE = function(c, tree) {\n    zip_send_bits(tree[c].fc, tree[c].dl);\n}\n\n/* Mapping from a distance to a distance code. dist is the distance - 1 and\n * must not have side effects. dist_code[256] and dist_code[257] are never\n * used.\n */\nvar zip_D_CODE = function(dist) {\n    return (dist < 256 ? zip_dist_code[dist]\n\t    : zip_dist_code[256 + (dist>>7)]) & 0xff;\n}\n\n/* ==========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nvar zip_SMALLER = function(tree, n, m) {\n    return tree[n].fc < tree[m].fc ||\n      (tree[n].fc == tree[m].fc && zip_depth[n] <= zip_depth[m]);\n}\n\n/* ==========================================================================\n * read string data\n */\nvar zip_read_buff = function(buff, offset, n) {\n    var i;\n    for(i = 0; i < n && zip_deflate_pos < zip_deflate_data.length; i++)\n\tbuff[offset + i] =\n\t    zip_deflate_data.charCodeAt(zip_deflate_pos++) & 0xff;\n    return i;\n}\n\n/* ==========================================================================\n * Initialize the \"longest match\" routines for a new file\n */\nvar zip_lm_init = function() {\n    var j;\n\n    /* Initialize the hash table. */\n    for(j = 0; j < zip_HASH_SIZE; j++)\n//\tzip_head2(j, zip_NIL);\n\tzip_prev[zip_WSIZE + j] = 0;\n    /* prev will be initialized on the fly */\n\n    /* Set the default configuration parameters:\n     */\n    zip_max_lazy_match = zip_configuration_table[zip_compr_level].max_lazy;\n    zip_good_match     = zip_configuration_table[zip_compr_level].good_length;\n    if(!zip_FULL_SEARCH)\n\tzip_nice_match = zip_configuration_table[zip_compr_level].nice_length;\n    zip_max_chain_length = zip_configuration_table[zip_compr_level].max_chain;\n\n    zip_strstart = 0;\n    zip_block_start = 0;\n\n    zip_lookahead = zip_read_buff(zip_window, 0, 2 * zip_WSIZE);\n    if(zip_lookahead <= 0) {\n\tzip_eofile = true;\n\tzip_lookahead = 0;\n\treturn;\n    }\n    zip_eofile = false;\n    /* Make sure that we always have enough lookahead. This is important\n     * if input comes from a device such as a tty.\n     */\n    while(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\n\tzip_fill_window();\n\n    /* If lookahead < MIN_MATCH, ins_h is garbage, but this is\n     * not important since only literal bytes will be emitted.\n     */\n    zip_ins_h = 0;\n    for(j = 0; j < zip_MIN_MATCH - 1; j++) {\n//      UPDATE_HASH(ins_h, window[j]);\n\tzip_ins_h = ((zip_ins_h << zip_H_SHIFT) ^ (zip_window[j] & 0xff)) & zip_HASH_MASK;\n    }\n}\n\n/* ==========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n */\nvar zip_longest_match = function(cur_match) {\n    var chain_length = zip_max_chain_length; // max hash chain length\n    var scanp = zip_strstart; // current string\n    var matchp;\t\t// matched string\n    var len;\t\t// length of current match\n    var best_len = zip_prev_length;\t// best match length so far\n\n    /* Stop when cur_match becomes <= limit. To simplify the code,\n     * we prevent matches with the string of window index 0.\n     */\n    var limit = (zip_strstart > zip_MAX_DIST ? zip_strstart - zip_MAX_DIST : zip_NIL);\n\n    var strendp = zip_strstart + zip_MAX_MATCH;\n    var scan_end1 = zip_window[scanp + best_len - 1];\n    var scan_end  = zip_window[scanp + best_len];\n\n    /* Do not waste too much time if we already have a good match: */\n    if(zip_prev_length >= zip_good_match)\n\tchain_length >>= 2;\n\n//  Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, \"insufficient lookahead\");\n\n    do {\n//    Assert(cur_match < encoder->strstart, \"no future\");\n\tmatchp = cur_match;\n\n\t/* Skip to next match if the match length cannot increase\n\t    * or if the match length is less than 2:\n\t*/\n\tif(zip_window[matchp + best_len]\t!= scan_end  ||\n\t   zip_window[matchp + best_len - 1]\t!= scan_end1 ||\n\t   zip_window[matchp]\t\t\t!= zip_window[scanp] ||\n\t   zip_window[++matchp]\t\t\t!= zip_window[scanp + 1]) {\n\t    continue;\n\t}\n\n\t/* The check at best_len-1 can be removed because it will be made\n         * again later. (This heuristic is not always a win.)\n         * It is not necessary to compare scan[2] and match[2] since they\n         * are always equal when the other bytes match, given that\n         * the hash keys are equal and that HASH_BITS >= 8.\n         */\n\tscanp += 2;\n\tmatchp++;\n\n\t/* We check for insufficient lookahead only every 8th comparison;\n         * the 256th check will be made at strstart+258.\n         */\n\tdo {\n\t} while(zip_window[++scanp] == zip_window[++matchp] &&\n\t\tzip_window[++scanp] == zip_window[++matchp] &&\n\t\tzip_window[++scanp] == zip_window[++matchp] &&\n\t\tzip_window[++scanp] == zip_window[++matchp] &&\n\t\tzip_window[++scanp] == zip_window[++matchp] &&\n\t\tzip_window[++scanp] == zip_window[++matchp] &&\n\t\tzip_window[++scanp] == zip_window[++matchp] &&\n\t\tzip_window[++scanp] == zip_window[++matchp] &&\n\t\tscanp < strendp);\n\n      len = zip_MAX_MATCH - (strendp - scanp);\n      scanp = strendp - zip_MAX_MATCH;\n\n      if(len > best_len) {\n\t  zip_match_start = cur_match;\n\t  best_len = len;\n\t  if(zip_FULL_SEARCH) {\n\t      if(len >= zip_MAX_MATCH) break;\n\t  } else {\n\t      if(len >= zip_nice_match) break;\n\t  }\n\n\t  scan_end1  = zip_window[scanp + best_len-1];\n\t  scan_end   = zip_window[scanp + best_len];\n      }\n    } while((cur_match = zip_prev[cur_match & zip_WMASK]) > limit\n\t    && --chain_length != 0);\n\n    return best_len;\n}\n\n/* ==========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead, and sets eofile if end of input file.\n * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0\n * OUT assertions: at least one byte has been read, or eofile is set;\n *    file reads are performed for at least two bytes (required for the\n *    translate_eol option).\n */\nvar zip_fill_window = function() {\n    var n, m;\n\n    // Amount of free space at the end of the window.\n    var more = zip_window_size - zip_lookahead - zip_strstart;\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if(more == -1) {\n\t/* Very unlikely, but possible on 16 bit machine if strstart == 0\n         * and lookahead == 1 (input done one byte at time)\n         */\n\tmore--;\n    } else if(zip_strstart >= zip_WSIZE + zip_MAX_DIST) {\n\t/* By the IN assertion, the window is not empty so we can't confuse\n         * more == 0 with more == 64K on a 16 bit machine.\n         */\n//\tAssert(window_size == (ulg)2*WSIZE, \"no sliding with BIG_MEM\");\n\n//\tSystem.arraycopy(window, WSIZE, window, 0, WSIZE);\n\tfor(n = 0; n < zip_WSIZE; n++)\n\t    zip_window[n] = zip_window[n + zip_WSIZE];\n      \n\tzip_match_start -= zip_WSIZE;\n\tzip_strstart    -= zip_WSIZE; /* we now have strstart >= MAX_DIST: */\n\tzip_block_start -= zip_WSIZE;\n\n\tfor(n = 0; n < zip_HASH_SIZE; n++) {\n\t    m = zip_head1(n);\n\t    zip_head2(n, m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\n\t}\n\tfor(n = 0; n < zip_WSIZE; n++) {\n\t    /* If n is not on any hash chain, prev[n] is garbage but\n\t     * its value will never be used.\n\t     */\n\t    m = zip_prev[n];\n\t    zip_prev[n] = (m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\n\t}\n\tmore += zip_WSIZE;\n    }\n    // At this point, more >= 2\n    if(!zip_eofile) {\n\tn = zip_read_buff(zip_window, zip_strstart + zip_lookahead, more);\n\tif(n <= 0)\n\t    zip_eofile = true;\n\telse\n\t    zip_lookahead += n;\n    }\n}\n\n/* ==========================================================================\n * Processes a new input file and return its compressed length. This\n * function does not perform lazy evaluationof matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nvar zip_deflate_fast = function() {\n    while(zip_lookahead != 0 && zip_qhead == null) {\n\tvar flush; // set if current block must be flushed\n\n\t/* Insert the string window[strstart .. strstart+2] in the\n\t * dictionary, and set hash_head to the head of the hash chain:\n\t */\n\tzip_INSERT_STRING();\n\n\t/* Find the longest match, discarding those <= prev_length.\n\t * At this point we have always match_length < MIN_MATCH\n\t */\n\tif(zip_hash_head != zip_NIL &&\n\t   zip_strstart - zip_hash_head <= zip_MAX_DIST) {\n\t    /* To simplify the code, we prevent matches with the string\n\t     * of window index 0 (in particular we have to avoid a match\n\t     * of the string with itself at the start of the input file).\n\t     */\n\t    zip_match_length = zip_longest_match(zip_hash_head);\n\t    /* longest_match() sets match_start */\n\t    if(zip_match_length > zip_lookahead)\n\t\tzip_match_length = zip_lookahead;\n\t}\n\tif(zip_match_length >= zip_MIN_MATCH) {\n//\t    check_match(strstart, match_start, match_length);\n\n\t    flush = zip_ct_tally(zip_strstart - zip_match_start,\n\t\t\t\t zip_match_length - zip_MIN_MATCH);\n\t    zip_lookahead -= zip_match_length;\n\n\t    /* Insert new strings in the hash table only if the match length\n\t     * is not too large. This saves time but degrades compression.\n\t     */\n\t    if(zip_match_length <= zip_max_lazy_match) {\n\t\tzip_match_length--; // string at strstart already in hash table\n\t\tdo {\n\t\t    zip_strstart++;\n\t\t    zip_INSERT_STRING();\n\t\t    /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n\t\t     * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n\t\t     * these bytes are garbage, but it does not matter since\n\t\t     * the next lookahead bytes will be emitted as literals.\n\t\t     */\n\t\t} while(--zip_match_length != 0);\n\t\tzip_strstart++;\n\t    } else {\n\t\tzip_strstart += zip_match_length;\n\t\tzip_match_length = 0;\n\t\tzip_ins_h = zip_window[zip_strstart] & 0xff;\n//\t\tUPDATE_HASH(ins_h, window[strstart + 1]);\n\t\tzip_ins_h = ((zip_ins_h<<zip_H_SHIFT) ^ (zip_window[zip_strstart + 1] & 0xff)) & zip_HASH_MASK;\n\n//#if MIN_MATCH != 3\n//\t\tCall UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n\n\t    }\n\t} else {\n\t    /* No match, output a literal byte */\n\t    flush = zip_ct_tally(0, zip_window[zip_strstart] & 0xff);\n\t    zip_lookahead--;\n\t    zip_strstart++;\n\t}\n\tif(flush) {\n\t    zip_flush_block(0);\n\t    zip_block_start = zip_strstart;\n\t}\n\n\t/* Make sure that we always have enough lookahead, except\n\t * at the end of the input file. We need MAX_MATCH bytes\n\t * for the next match, plus MIN_MATCH bytes to insert the\n\t * string following the next match.\n\t */\n\twhile(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\n\t    zip_fill_window();\n    }\n}\n\nvar zip_deflate_better = function() {\n    /* Process the input block. */\n    while(zip_lookahead != 0 && zip_qhead == null) {\n\t/* Insert the string window[strstart .. strstart+2] in the\n\t * dictionary, and set hash_head to the head of the hash chain:\n\t */\n\tzip_INSERT_STRING();\n\n\t/* Find the longest match, discarding those <= prev_length.\n\t */\n\tzip_prev_length = zip_match_length;\n\tzip_prev_match = zip_match_start;\n\tzip_match_length = zip_MIN_MATCH - 1;\n\n\tif(zip_hash_head != zip_NIL &&\n\t   zip_prev_length < zip_max_lazy_match &&\n\t   zip_strstart - zip_hash_head <= zip_MAX_DIST) {\n\t    /* To simplify the code, we prevent matches with the string\n\t     * of window index 0 (in particular we have to avoid a match\n\t     * of the string with itself at the start of the input file).\n\t     */\n\t    zip_match_length = zip_longest_match(zip_hash_head);\n\t    /* longest_match() sets match_start */\n\t    if(zip_match_length > zip_lookahead)\n\t\tzip_match_length = zip_lookahead;\n\n\t    /* Ignore a length 3 match if it is too distant: */\n\t    if(zip_match_length == zip_MIN_MATCH &&\n\t       zip_strstart - zip_match_start > zip_TOO_FAR) {\n\t\t/* If prev_match is also MIN_MATCH, match_start is garbage\n\t\t * but we will ignore the current match anyway.\n\t\t */\n\t\tzip_match_length--;\n\t    }\n\t}\n\t/* If there was a match at the previous step and the current\n\t * match is not better, output the previous match:\n\t */\n\tif(zip_prev_length >= zip_MIN_MATCH &&\n\t   zip_match_length <= zip_prev_length) {\n\t    var flush; // set if current block must be flushed\n\n//\t    check_match(strstart - 1, prev_match, prev_length);\n\t    flush = zip_ct_tally(zip_strstart - 1 - zip_prev_match,\n\t\t\t\t zip_prev_length - zip_MIN_MATCH);\n\n\t    /* Insert in hash table all strings up to the end of the match.\n\t     * strstart-1 and strstart are already inserted.\n\t     */\n\t    zip_lookahead -= zip_prev_length - 1;\n\t    zip_prev_length -= 2;\n\t    do {\n\t\tzip_strstart++;\n\t\tzip_INSERT_STRING();\n\t\t/* strstart never exceeds WSIZE-MAX_MATCH, so there are\n\t\t * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n\t\t * these bytes are garbage, but it does not matter since the\n\t\t * next lookahead bytes will always be emitted as literals.\n\t\t */\n\t    } while(--zip_prev_length != 0);\n\t    zip_match_available = 0;\n\t    zip_match_length = zip_MIN_MATCH - 1;\n\t    zip_strstart++;\n\t    if(flush) {\n\t\tzip_flush_block(0);\n\t\tzip_block_start = zip_strstart;\n\t    }\n\t} else if(zip_match_available != 0) {\n\t    /* If there was no match at the previous position, output a\n\t     * single literal. If there was a match but the current match\n\t     * is longer, truncate the previous match to a single literal.\n\t     */\n\t    if(zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff)) {\n\t\tzip_flush_block(0);\n\t\tzip_block_start = zip_strstart;\n\t    }\n\t    zip_strstart++;\n\t    zip_lookahead--;\n\t} else {\n\t    /* There is no previous match to compare with, wait for\n\t     * the next step to decide.\n\t     */\n\t    zip_match_available = 1;\n\t    zip_strstart++;\n\t    zip_lookahead--;\n\t}\n\n\t/* Make sure that we always have enough lookahead, except\n\t * at the end of the input file. We need MAX_MATCH bytes\n\t * for the next match, plus MIN_MATCH bytes to insert the\n\t * string following the next match.\n\t */\n\twhile(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\n\t    zip_fill_window();\n    }\n}\n\nvar zip_init_deflate = function() {\n    if(zip_eofile)\n\treturn;\n    zip_bi_buf = 0;\n    zip_bi_valid = 0;\n    zip_ct_init();\n    zip_lm_init();\n\n    zip_qhead = null;\n    zip_outcnt = 0;\n    zip_outoff = 0;\n\n    if(zip_compr_level <= 3)\n    {\n\tzip_prev_length = zip_MIN_MATCH - 1;\n\tzip_match_length = 0;\n    }\n    else\n    {\n\tzip_match_length = zip_MIN_MATCH - 1;\n\tzip_match_available = 0;\n    }\n\n    zip_complete = false;\n}\n\n/* ==========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nvar zip_deflate_internal = function(buff, off, buff_size) {\n    var n;\n\n    if(!zip_initflag)\n    {\n\tzip_init_deflate();\n\tzip_initflag = true;\n\tif(zip_lookahead == 0) { // empty\n\t    zip_complete = true;\n\t    return 0;\n\t}\n    }\n\n    if((n = zip_qcopy(buff, off, buff_size)) == buff_size)\n\treturn buff_size;\n\n    if(zip_complete)\n\treturn n;\n\n    if(zip_compr_level <= 3) // optimized for speed\n\tzip_deflate_fast();\n    else\n\tzip_deflate_better();\n    if(zip_lookahead == 0) {\n\tif(zip_match_available != 0)\n\t    zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff);\n\tzip_flush_block(1);\n\tzip_complete = true;\n    }\n    return n + zip_qcopy(buff, n + off, buff_size - n);\n}\n\nvar zip_qcopy = function(buff, off, buff_size) {\n    var n, i, j;\n\n    n = 0;\n    while(zip_qhead != null && n < buff_size)\n    {\n\ti = buff_size - n;\n\tif(i > zip_qhead.len)\n\t    i = zip_qhead.len;\n//      System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);\n\tfor(j = 0; j < i; j++)\n\t    buff[off + n + j] = zip_qhead.ptr[zip_qhead.off + j];\n\t\n\tzip_qhead.off += i;\n\tzip_qhead.len -= i;\n\tn += i;\n\tif(zip_qhead.len == 0) {\n\t    var p;\n\t    p = zip_qhead;\n\t    zip_qhead = zip_qhead.next;\n\t    zip_reuse_queue(p);\n\t}\n    }\n\n    if(n == buff_size)\n\treturn n;\n\n    if(zip_outoff < zip_outcnt) {\n\ti = buff_size - n;\n\tif(i > zip_outcnt - zip_outoff)\n\t    i = zip_outcnt - zip_outoff;\n\t// System.arraycopy(outbuf, outoff, buff, off + n, i);\n\tfor(j = 0; j < i; j++)\n\t    buff[off + n + j] = zip_outbuf[zip_outoff + j];\n\tzip_outoff += i;\n\tn += i;\n\tif(zip_outcnt == zip_outoff)\n\t    zip_outcnt = zip_outoff = 0;\n    }\n    return n;\n}\n\n/* ==========================================================================\n * Allocate the match buffer, initialize the various tables and save the\n * location of the internal file attribute (ascii/binary) and method\n * (DEFLATE/STORE).\n */\nvar zip_ct_init = function() {\n    var n;\t// iterates over tree elements\n    var bits;\t// bit counter\n    var length;\t// length value\n    var code;\t// code value\n    var dist;\t// distance index\n\n    if(zip_static_dtree[0].dl != 0) return; // ct_init already called\n\n    zip_l_desc.dyn_tree\t\t= zip_dyn_ltree;\n    zip_l_desc.static_tree\t= zip_static_ltree;\n    zip_l_desc.extra_bits\t= zip_extra_lbits;\n    zip_l_desc.extra_base\t= zip_LITERALS + 1;\n    zip_l_desc.elems\t\t= zip_L_CODES;\n    zip_l_desc.max_length\t= zip_MAX_BITS;\n    zip_l_desc.max_code\t\t= 0;\n\n    zip_d_desc.dyn_tree\t\t= zip_dyn_dtree;\n    zip_d_desc.static_tree\t= zip_static_dtree;\n    zip_d_desc.extra_bits\t= zip_extra_dbits;\n    zip_d_desc.extra_base\t= 0;\n    zip_d_desc.elems\t\t= zip_D_CODES;\n    zip_d_desc.max_length\t= zip_MAX_BITS;\n    zip_d_desc.max_code\t\t= 0;\n\n    zip_bl_desc.dyn_tree\t= zip_bl_tree;\n    zip_bl_desc.static_tree\t= null;\n    zip_bl_desc.extra_bits\t= zip_extra_blbits;\n    zip_bl_desc.extra_base\t= 0;\n    zip_bl_desc.elems\t\t= zip_BL_CODES;\n    zip_bl_desc.max_length\t= zip_MAX_BL_BITS;\n    zip_bl_desc.max_code\t= 0;\n\n    // Initialize the mapping length (0..255) -> length code (0..28)\n    length = 0;\n    for(code = 0; code < zip_LENGTH_CODES-1; code++) {\n\tzip_base_length[code] = length;\n\tfor(n = 0; n < (1<<zip_extra_lbits[code]); n++)\n\t    zip_length_code[length++] = code;\n    }\n    // Assert (length == 256, \"ct_init: length != 256\");\n\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n    zip_length_code[length-1] = code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for(code = 0 ; code < 16; code++) {\n\tzip_base_dist[code] = dist;\n\tfor(n = 0; n < (1<<zip_extra_dbits[code]); n++) {\n\t    zip_dist_code[dist++] = code;\n\t}\n    }\n    // Assert (dist == 256, \"ct_init: dist != 256\");\n    dist >>= 7; // from now on, all distances are divided by 128\n    for( ; code < zip_D_CODES; code++) {\n\tzip_base_dist[code] = dist << 7;\n\tfor(n = 0; n < (1<<(zip_extra_dbits[code]-7)); n++)\n\t    zip_dist_code[256 + dist++] = code;\n    }\n    // Assert (dist == 256, \"ct_init: 256+dist != 512\");\n\n    // Construct the codes of the static literal tree\n    for(bits = 0; bits <= zip_MAX_BITS; bits++)\n\tzip_bl_count[bits] = 0;\n    n = 0;\n    while(n <= 143) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }\n    while(n <= 255) { zip_static_ltree[n++].dl = 9; zip_bl_count[9]++; }\n    while(n <= 279) { zip_static_ltree[n++].dl = 7; zip_bl_count[7]++; }\n    while(n <= 287) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    zip_gen_codes(zip_static_ltree, zip_L_CODES + 1);\n\n    /* The static distance tree is trivial: */\n    for(n = 0; n < zip_D_CODES; n++) {\n\tzip_static_dtree[n].dl = 5;\n\tzip_static_dtree[n].fc = zip_bi_reverse(n, 5);\n    }\n\n    // Initialize the first block of the first file:\n    zip_init_block();\n}\n\n/* ==========================================================================\n * Initialize a new block.\n */\nvar zip_init_block = function() {\n    var n; // iterates over tree elements\n\n    // Initialize the trees.\n    for(n = 0; n < zip_L_CODES;  n++) zip_dyn_ltree[n].fc = 0;\n    for(n = 0; n < zip_D_CODES;  n++) zip_dyn_dtree[n].fc = 0;\n    for(n = 0; n < zip_BL_CODES; n++) zip_bl_tree[n].fc = 0;\n\n    zip_dyn_ltree[zip_END_BLOCK].fc = 1;\n    zip_opt_len = zip_static_len = 0;\n    zip_last_lit = zip_last_dist = zip_last_flags = 0;\n    zip_flags = 0;\n    zip_flag_bit = 1;\n}\n\n/* ==========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nvar zip_pqdownheap = function(\n    tree,\t// the tree to restore\n    k) {\t// node to move down\n    var v = zip_heap[k];\n    var j = k << 1;\t// left son of k\n\n    while(j <= zip_heap_len) {\n\t// Set j to the smallest of the two sons:\n\tif(j < zip_heap_len &&\n\t   zip_SMALLER(tree, zip_heap[j + 1], zip_heap[j]))\n\t    j++;\n\n\t// Exit if v is smaller than both sons\n\tif(zip_SMALLER(tree, v, zip_heap[j]))\n\t    break;\n\n\t// Exchange v with the smallest son\n\tzip_heap[k] = zip_heap[j];\n\tk = j;\n\n\t// And continue down the tree, setting j to the left son of k\n\tj <<= 1;\n    }\n    zip_heap[k] = v;\n}\n\n/* ==========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nvar zip_gen_bitlen = function(desc) { // the tree descriptor\n    var tree\t\t= desc.dyn_tree;\n    var extra\t\t= desc.extra_bits;\n    var base\t\t= desc.extra_base;\n    var max_code\t= desc.max_code;\n    var max_length\t= desc.max_length;\n    var stree\t\t= desc.static_tree;\n    var h;\t\t// heap index\n    var n, m;\t\t// iterate over the tree elements\n    var bits;\t\t// bit length\n    var xbits;\t\t// extra bits\n    var f;\t\t// frequency\n    var overflow = 0;\t// number of elements with bit length too large\n\n    for(bits = 0; bits <= zip_MAX_BITS; bits++)\n\tzip_bl_count[bits] = 0;\n\n    /* In a first pass, compute the optimal bit lengths (which may\n     * overflow in the case of the bit length tree).\n     */\n    tree[zip_heap[zip_heap_max]].dl = 0; // root of the heap\n\n    for(h = zip_heap_max + 1; h < zip_HEAP_SIZE; h++) {\n\tn = zip_heap[h];\n\tbits = tree[tree[n].dl].dl + 1;\n\tif(bits > max_length) {\n\t    bits = max_length;\n\t    overflow++;\n\t}\n\ttree[n].dl = bits;\n\t// We overwrite tree[n].dl which is no longer needed\n\n\tif(n > max_code)\n\t    continue; // not a leaf node\n\n\tzip_bl_count[bits]++;\n\txbits = 0;\n\tif(n >= base)\n\t    xbits = extra[n - base];\n\tf = tree[n].fc;\n\tzip_opt_len += f * (bits + xbits);\n\tif(stree != null)\n\t    zip_static_len += f * (stree[n].dl + xbits);\n    }\n    if(overflow == 0)\n\treturn;\n\n    // This happens for example on obj2 and pic of the Calgary corpus\n\n    // Find the first bit length which could increase:\n    do {\n\tbits = max_length - 1;\n\twhile(zip_bl_count[bits] == 0)\n\t    bits--;\n\tzip_bl_count[bits]--;\t\t// move one leaf down the tree\n\tzip_bl_count[bits + 1] += 2;\t// move one overflow item as its brother\n\tzip_bl_count[max_length]--;\n\t/* The brother of the overflow item also moves one step up,\n\t * but this does not affect bl_count[max_length]\n\t */\n\toverflow -= 2;\n    } while(overflow > 0);\n\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n     * lengths instead of fixing only the wrong ones. This idea is taken\n     * from 'ar' written by Haruhiko Okumura.)\n     */\n    for(bits = max_length; bits != 0; bits--) {\n\tn = zip_bl_count[bits];\n\twhile(n != 0) {\n\t    m = zip_heap[--h];\n\t    if(m > max_code)\n\t\tcontinue;\n\t    if(tree[m].dl != bits) {\n\t\tzip_opt_len += (bits - tree[m].dl) * tree[m].fc;\n\t\ttree[m].fc = bits;\n\t    }\n\t    n--;\n\t}\n    }\n}\n\n  /* ==========================================================================\n   * Generate the codes for a given tree and bit counts (which need not be\n   * optimal).\n   * IN assertion: the array bl_count contains the bit length statistics for\n   * the given tree and the field len is set for all tree elements.\n   * OUT assertion: the field code is set for all tree elements of non\n   *     zero code length.\n   */\nvar zip_gen_codes = function(tree,\t// the tree to decorate\n\t\t   max_code) {\t// largest code with non zero frequency\n    var next_code = new Array(zip_MAX_BITS+1); // next code value for each bit length\n    var code = 0;\t\t// running code value\n    var bits;\t\t\t// bit index\n    var n;\t\t\t// code index\n\n    /* The distribution counts are first used to generate the code values\n     * without bit reversal.\n     */\n    for(bits = 1; bits <= zip_MAX_BITS; bits++) {\n\tcode = ((code + zip_bl_count[bits-1]) << 1);\n\tnext_code[bits] = code;\n    }\n\n    /* Check that the bit counts in bl_count are consistent. The last code\n     * must be all ones.\n     */\n//    Assert (code + encoder->bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n//\t    \"inconsistent bit counts\");\n//    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n    for(n = 0; n <= max_code; n++) {\n\tvar len = tree[n].dl;\n\tif(len == 0)\n\t    continue;\n\t// Now reverse the bits\n\ttree[n].fc = zip_bi_reverse(next_code[len]++, len);\n\n//      Tracec(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n//\t  n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));\n    }\n}\n\n/* ==========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nvar zip_build_tree = function(desc) { // the tree descriptor\n    var tree\t= desc.dyn_tree;\n    var stree\t= desc.static_tree;\n    var elems\t= desc.elems;\n    var n, m;\t\t// iterate over heap elements\n    var max_code = -1;\t// largest code with non zero frequency\n    var node = elems;\t// next internal node of the tree\n\n    /* Construct the initial heap, with least frequent element in\n     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n     * heap[0] is not used.\n     */\n    zip_heap_len = 0;\n    zip_heap_max = zip_HEAP_SIZE;\n\n    for(n = 0; n < elems; n++) {\n\tif(tree[n].fc != 0) {\n\t    zip_heap[++zip_heap_len] = max_code = n;\n\t    zip_depth[n] = 0;\n\t} else\n\t    tree[n].dl = 0;\n    }\n\n    /* The pkzip format requires that at least one distance code exists,\n     * and that at least one bit should be sent even if there is only one\n     * possible code. So to avoid special checks later on we force at least\n     * two codes of non zero frequency.\n     */\n    while(zip_heap_len < 2) {\n\tvar xnew = zip_heap[++zip_heap_len] = (max_code < 2 ? ++max_code : 0);\n\ttree[xnew].fc = 1;\n\tzip_depth[xnew] = 0;\n\tzip_opt_len--;\n\tif(stree != null)\n\t    zip_static_len -= stree[xnew].dl;\n\t// new is 0 or 1 so it does not have extra bits\n    }\n    desc.max_code = max_code;\n\n    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n     * establish sub-heaps of increasing lengths:\n     */\n    for(n = zip_heap_len >> 1; n >= 1; n--)\n\tzip_pqdownheap(tree, n);\n\n    /* Construct the Huffman tree by repeatedly combining the least two\n     * frequent nodes.\n     */\n    do {\n\tn = zip_heap[zip_SMALLEST];\n\tzip_heap[zip_SMALLEST] = zip_heap[zip_heap_len--];\n\tzip_pqdownheap(tree, zip_SMALLEST);\n\n\tm = zip_heap[zip_SMALLEST];  // m = node of next least frequency\n\n\t// keep the nodes sorted by frequency\n\tzip_heap[--zip_heap_max] = n;\n\tzip_heap[--zip_heap_max] = m;\n\n\t// Create a new node father of n and m\n\ttree[node].fc = tree[n].fc + tree[m].fc;\n//\tdepth[node] = (char)(MAX(depth[n], depth[m]) + 1);\n\tif(zip_depth[n] > zip_depth[m] + 1)\n\t    zip_depth[node] = zip_depth[n];\n\telse\n\t    zip_depth[node] = zip_depth[m] + 1;\n\ttree[n].dl = tree[m].dl = node;\n\n\t// and insert the new node in the heap\n\tzip_heap[zip_SMALLEST] = node++;\n\tzip_pqdownheap(tree, zip_SMALLEST);\n\n    } while(zip_heap_len >= 2);\n\n    zip_heap[--zip_heap_max] = zip_heap[zip_SMALLEST];\n\n    /* At this point, the fields freq and dad are set. We can now\n     * generate the bit lengths.\n     */\n    zip_gen_bitlen(desc);\n\n    // The field len is now set, we can generate the bit codes\n    zip_gen_codes(tree, max_code);\n}\n\n/* ==========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree. Updates opt_len to take into account the repeat\n * counts. (The contribution of the bit length codes will be added later\n * during the construction of bl_tree.)\n */\nvar zip_scan_tree = function(tree,// the tree to be scanned\n\t\t       max_code) {  // and its largest code of non zero frequency\n    var n;\t\t\t// iterates over all tree elements\n    var prevlen = -1;\t\t// last emitted length\n    var curlen;\t\t\t// length of current code\n    var nextlen = tree[0].dl;\t// length of next code\n    var count = 0;\t\t// repeat count of the current code\n    var max_count = 7;\t\t// max repeat count\n    var min_count = 4;\t\t// min repeat count\n\n    if(nextlen == 0) {\n\tmax_count = 138;\n\tmin_count = 3;\n    }\n    tree[max_code + 1].dl = 0xffff; // guard\n\n    for(n = 0; n <= max_code; n++) {\n\tcurlen = nextlen;\n\tnextlen = tree[n + 1].dl;\n\tif(++count < max_count && curlen == nextlen)\n\t    continue;\n\telse if(count < min_count)\n\t    zip_bl_tree[curlen].fc += count;\n\telse if(curlen != 0) {\n\t    if(curlen != prevlen)\n\t\tzip_bl_tree[curlen].fc++;\n\t    zip_bl_tree[zip_REP_3_6].fc++;\n\t} else if(count <= 10)\n\t    zip_bl_tree[zip_REPZ_3_10].fc++;\n\telse\n\t    zip_bl_tree[zip_REPZ_11_138].fc++;\n\tcount = 0; prevlen = curlen;\n\tif(nextlen == 0) {\n\t    max_count = 138;\n\t    min_count = 3;\n\t} else if(curlen == nextlen) {\n\t    max_count = 6;\n\t    min_count = 3;\n\t} else {\n\t    max_count = 7;\n\t    min_count = 4;\n\t}\n    }\n}\n\n  /* ==========================================================================\n   * Send a literal or distance tree in compressed form, using the codes in\n   * bl_tree.\n   */\nvar zip_send_tree = function(tree, // the tree to be scanned\n\t\t   max_code) { // and its largest code of non zero frequency\n    var n;\t\t\t// iterates over all tree elements\n    var prevlen = -1;\t\t// last emitted length\n    var curlen;\t\t\t// length of current code\n    var nextlen = tree[0].dl;\t// length of next code\n    var count = 0;\t\t// repeat count of the current code\n    var max_count = 7;\t\t// max repeat count\n    var min_count = 4;\t\t// min repeat count\n\n    /* tree[max_code+1].dl = -1; */  /* guard already set */\n    if(nextlen == 0) {\n      max_count = 138;\n      min_count = 3;\n    }\n\n    for(n = 0; n <= max_code; n++) {\n\tcurlen = nextlen;\n\tnextlen = tree[n+1].dl;\n\tif(++count < max_count && curlen == nextlen) {\n\t    continue;\n\t} else if(count < min_count) {\n\t    do { zip_SEND_CODE(curlen, zip_bl_tree); } while(--count != 0);\n\t} else if(curlen != 0) {\n\t    if(curlen != prevlen) {\n\t\tzip_SEND_CODE(curlen, zip_bl_tree);\n\t\tcount--;\n\t    }\n\t    // Assert(count >= 3 && count <= 6, \" 3_6?\");\n\t    zip_SEND_CODE(zip_REP_3_6, zip_bl_tree);\n\t    zip_send_bits(count - 3, 2);\n\t} else if(count <= 10) {\n\t    zip_SEND_CODE(zip_REPZ_3_10, zip_bl_tree);\n\t    zip_send_bits(count-3, 3);\n\t} else {\n\t    zip_SEND_CODE(zip_REPZ_11_138, zip_bl_tree);\n\t    zip_send_bits(count-11, 7);\n\t}\n\tcount = 0;\n\tprevlen = curlen;\n\tif(nextlen == 0) {\n\t    max_count = 138;\n\t    min_count = 3;\n\t} else if(curlen == nextlen) {\n\t    max_count = 6;\n\t    min_count = 3;\n\t} else {\n\t    max_count = 7;\n\t    min_count = 4;\n\t}\n    }\n}\n\n/* ==========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nvar zip_build_bl_tree = function() {\n    var max_blindex;  // index of last bit length code of non zero freq\n\n    // Determine the bit length frequencies for literal and distance trees\n    zip_scan_tree(zip_dyn_ltree, zip_l_desc.max_code);\n    zip_scan_tree(zip_dyn_dtree, zip_d_desc.max_code);\n\n    // Build the bit length tree:\n    zip_build_tree(zip_bl_desc);\n    /* opt_len now includes the length of the tree representations, except\n     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n     */\n\n    /* Determine the number of bit length codes to send. The pkzip format\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\n     * 3 but the actual value used is 4.)\n     */\n    for(max_blindex = zip_BL_CODES-1; max_blindex >= 3; max_blindex--) {\n\tif(zip_bl_tree[zip_bl_order[max_blindex]].dl != 0) break;\n    }\n    /* Update opt_len to include the bit length tree and counts */\n    zip_opt_len += 3*(max_blindex+1) + 5+5+4;\n//    Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n//\t    encoder->opt_len, encoder->static_len));\n\n    return max_blindex;\n}\n\n/* ==========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nvar zip_send_all_trees = function(lcodes, dcodes, blcodes) { // number of codes for each tree\n    var rank; // index in bl_order\n\n//    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n//    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n//\t    \"too many codes\");\n//    Tracev((stderr, \"\\nbl counts: \"));\n    zip_send_bits(lcodes-257, 5); // not +255 as stated in appnote.txt\n    zip_send_bits(dcodes-1,   5);\n    zip_send_bits(blcodes-4,  4); // not -3 as stated in appnote.txt\n    for(rank = 0; rank < blcodes; rank++) {\n//      Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n\tzip_send_bits(zip_bl_tree[zip_bl_order[rank]].dl, 3);\n    }\n\n    // send the literal tree\n    zip_send_tree(zip_dyn_ltree,lcodes-1);\n\n    // send the distance tree\n    zip_send_tree(zip_dyn_dtree,dcodes-1);\n}\n\n/* ==========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nvar zip_flush_block = function(eof) { // true if this is the last block for a file\n    var opt_lenb, static_lenb; // opt_len and static_len in bytes\n    var max_blindex;\t// index of last bit length code of non zero freq\n    var stored_len;\t// length of input block\n\n    stored_len = zip_strstart - zip_block_start;\n    zip_flag_buf[zip_last_flags] = zip_flags; // Save the flags for the last 8 items\n\n    // Construct the literal and distance trees\n    zip_build_tree(zip_l_desc);\n//    Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\",\n//\t    encoder->opt_len, encoder->static_len));\n\n    zip_build_tree(zip_d_desc);\n//    Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\",\n//\t    encoder->opt_len, encoder->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = zip_build_bl_tree();\n\n    // Determine the best encoding. Compute first the block length in bytes\n    opt_lenb\t= (zip_opt_len   +3+7)>>3;\n    static_lenb = (zip_static_len+3+7)>>3;\n\n//    Trace((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u \",\n//\t   opt_lenb, encoder->opt_len,\n//\t   static_lenb, encoder->static_len, stored_len,\n//\t   encoder->last_lit, encoder->last_dist));\n\n    if(static_lenb <= opt_lenb)\n\topt_lenb = static_lenb;\n    if(stored_len + 4 <= opt_lenb // 4: two words for the lengths\n       && zip_block_start >= 0) {\n\tvar i;\n\n\t/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n\t * Otherwise we can't have processed more than WSIZE input bytes since\n\t * the last block flush, because compression would have been\n\t * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n\t * transform a block into a stored block.\n\t */\n\tzip_send_bits((zip_STORED_BLOCK<<1)+eof, 3);  /* send block type */\n\tzip_bi_windup();\t\t /* align on byte boundary */\n\tzip_put_short(stored_len);\n\tzip_put_short(~stored_len);\n\n      // copy block\n/*\n      p = &window[block_start];\n      for(i = 0; i < stored_len; i++)\n\tput_byte(p[i]);\n*/\n\tfor(i = 0; i < stored_len; i++)\n\t    zip_put_byte(zip_window[zip_block_start + i]);\n\n    } else if(static_lenb == opt_lenb) {\n\tzip_send_bits((zip_STATIC_TREES<<1)+eof, 3);\n\tzip_compress_block(zip_static_ltree, zip_static_dtree);\n    } else {\n\tzip_send_bits((zip_DYN_TREES<<1)+eof, 3);\n\tzip_send_all_trees(zip_l_desc.max_code+1,\n\t\t\t   zip_d_desc.max_code+1,\n\t\t\t   max_blindex+1);\n\tzip_compress_block(zip_dyn_ltree, zip_dyn_dtree);\n    }\n\n    zip_init_block();\n\n    if(eof != 0)\n\tzip_bi_windup();\n}\n\n/* ==========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nvar zip_ct_tally = function(\n\tdist, // distance of matched string\n\tlc) { // match length-MIN_MATCH or unmatched char (if dist==0)\n    zip_l_buf[zip_last_lit++] = lc;\n    if(dist == 0) {\n\t// lc is the unmatched char\n\tzip_dyn_ltree[lc].fc++;\n    } else {\n\t// Here, lc is the match length - MIN_MATCH\n\tdist--;\t\t    // dist = match distance - 1\n//      Assert((ush)dist < (ush)MAX_DIST &&\n//\t     (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n//\t     (ush)D_CODE(dist) < (ush)D_CODES,  \"ct_tally: bad match\");\n\n\tzip_dyn_ltree[zip_length_code[lc]+zip_LITERALS+1].fc++;\n\tzip_dyn_dtree[zip_D_CODE(dist)].fc++;\n\n\tzip_d_buf[zip_last_dist++] = dist;\n\tzip_flags |= zip_flag_bit;\n    }\n    zip_flag_bit <<= 1;\n\n    // Output the flags if they fill a byte\n    if((zip_last_lit & 7) == 0) {\n\tzip_flag_buf[zip_last_flags++] = zip_flags;\n\tzip_flags = 0;\n\tzip_flag_bit = 1;\n    }\n    // Try to guess if it is profitable to stop the current block here\n    if(zip_compr_level > 2 && (zip_last_lit & 0xfff) == 0) {\n\t// Compute an upper bound for the compressed length\n\tvar out_length = zip_last_lit * 8;\n\tvar in_length = zip_strstart - zip_block_start;\n\tvar dcode;\n\n\tfor(dcode = 0; dcode < zip_D_CODES; dcode++) {\n\t    out_length += zip_dyn_dtree[dcode].fc * (5 + zip_extra_dbits[dcode]);\n\t}\n\tout_length >>= 3;\n//      Trace((stderr,\"\\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) \",\n//\t     encoder->last_lit, encoder->last_dist, in_length, out_length,\n//\t     100L - out_length*100L/in_length));\n\tif(zip_last_dist < parseInt(zip_last_lit/2) &&\n\t   out_length < parseInt(in_length/2))\n\t    return true;\n    }\n    return (zip_last_lit == zip_LIT_BUFSIZE-1 ||\n\t    zip_last_dist == zip_DIST_BUFSIZE);\n    /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K\n     * on 16 bit machines and because stored blocks are restricted to\n     * 64K-1 bytes.\n     */\n}\n\n  /* ==========================================================================\n   * Send the block data compressed using the given Huffman trees\n   */\nvar zip_compress_block = function(\n\tltree,\t// literal tree\n\tdtree) {\t// distance tree\n    var dist;\t\t// distance of matched string\n    var lc;\t\t// match length or unmatched char (if dist == 0)\n    var lx = 0;\t\t// running index in l_buf\n    var dx = 0;\t\t// running index in d_buf\n    var fx = 0;\t\t// running index in flag_buf\n    var flag = 0;\t// current flags\n    var code;\t\t// the code to send\n    var extra;\t\t// number of extra bits to send\n\n    if(zip_last_lit != 0) do {\n\tif((lx & 7) == 0)\n\t    flag = zip_flag_buf[fx++];\n\tlc = zip_l_buf[lx++] & 0xff;\n\tif((flag & 1) == 0) {\n\t    zip_SEND_CODE(lc, ltree); /* send a literal byte */\n//\tTracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n\t} else {\n\t    // Here, lc is the match length - MIN_MATCH\n\t    code = zip_length_code[lc];\n\t    zip_SEND_CODE(code+zip_LITERALS+1, ltree); // send the length code\n\t    extra = zip_extra_lbits[code];\n\t    if(extra != 0) {\n\t\tlc -= zip_base_length[code];\n\t\tzip_send_bits(lc, extra); // send the extra length bits\n\t    }\n\t    dist = zip_d_buf[dx++];\n\t    // Here, dist is the match distance - 1\n\t    code = zip_D_CODE(dist);\n//\tAssert (code < D_CODES, \"bad d_code\");\n\n\t    zip_SEND_CODE(code, dtree);\t  // send the distance code\n\t    extra = zip_extra_dbits[code];\n\t    if(extra != 0) {\n\t\tdist -= zip_base_dist[code];\n\t\tzip_send_bits(dist, extra);   // send the extra distance bits\n\t    }\n\t} // literal or match pair ?\n\tflag >>= 1;\n    } while(lx < zip_last_lit);\n\n    zip_SEND_CODE(zip_END_BLOCK, ltree);\n}\n\n/* ==========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nvar zip_Buf_size = 16; // bit size of bi_buf\nvar zip_send_bits = function(\n\tvalue,\t// value to send\n\tlength) {\t// number of bits\n    /* If not enough room in bi_buf, use (valid) bits from bi_buf and\n     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\n     * unused bits in value.\n     */\n    if(zip_bi_valid > zip_Buf_size - length) {\n\tzip_bi_buf |= (value << zip_bi_valid);\n\tzip_put_short(zip_bi_buf);\n\tzip_bi_buf = (value >> (zip_Buf_size - zip_bi_valid));\n\tzip_bi_valid += length - zip_Buf_size;\n    } else {\n\tzip_bi_buf |= value << zip_bi_valid;\n\tzip_bi_valid += length;\n    }\n}\n\n/* ==========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nvar zip_bi_reverse = function(\n\tcode,\t// the value to invert\n\tlen) {\t// its bit length\n    var res = 0;\n    do {\n\tres |= code & 1;\n\tcode >>= 1;\n\tres <<= 1;\n    } while(--len > 0);\n    return res >> 1;\n}\n\n/* ==========================================================================\n * Write out any remaining bits in an incomplete byte.\n */\nvar zip_bi_windup = function() {\n    if(zip_bi_valid > 8) {\n\tzip_put_short(zip_bi_buf);\n    } else if(zip_bi_valid > 0) {\n\tzip_put_byte(zip_bi_buf);\n    }\n    zip_bi_buf = 0;\n    zip_bi_valid = 0;\n}\n\nvar zip_qoutbuf = function() {\n    if(zip_outcnt != 0) {\n\tvar q, i;\n\tq = zip_new_queue();\n\tif(zip_qhead == null)\n\t    zip_qhead = zip_qtail = q;\n\telse\n\t    zip_qtail = zip_qtail.next = q;\n\tq.len = zip_outcnt - zip_outoff;\n//      System.arraycopy(zip_outbuf, zip_outoff, q.ptr, 0, q.len);\n\tfor(i = 0; i < q.len; i++)\n\t    q.ptr[i] = zip_outbuf[zip_outoff + i];\n\tzip_outcnt = zip_outoff = 0;\n    }\n}\n\nvar zip_deflate = function(str, level) {\n    var i, j;\n\n    zip_deflate_data = str;\n    zip_deflate_pos = 0;\n    if(typeof level == \"undefined\")\n\tlevel = zip_DEFAULT_LEVEL;\n    zip_deflate_start(level);\n\n    var buff = new Array(1024);\n    var aout = [];\n    while((i = zip_deflate_internal(buff, 0, buff.length)) > 0) {\n\tvar cbuf = new Array(i);\n\tfor(j = 0; j < i; j++){\n\t    cbuf[j] = String.fromCharCode(buff[j]);\n\t}\n\taout[aout.length] = cbuf.join(\"\");\n    }\n    zip_deflate_data = null; // G.C.\n    return aout.join(\"\");\n}\n\nif (! window.RawDeflate) RawDeflate = {};\nRawDeflate.deflate = zip_deflate;\n\n})();"]],"start1":0,"start2":0,"length1":0,"length2":53776}]],"length":53776}
